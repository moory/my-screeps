module.exports = {
    run(creep) {
        // æ£€æŸ¥æˆ¿é—´æ˜¯å¦å¤„äºŽæ”»å‡»çŠ¶æ€
        if (creep.room.memory.underAttack) {
            // å¯»æ‰¾æœ€è¿‘çš„å¡”æ¥æä¾›èƒ½é‡
            const tower = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_TOWER && 
                           s.store.getFreeCapacity(RESOURCE_ENERGY) > 0
            });
            
            // å¦‚æžœæœ‰å¡”å¹¶ä¸”èƒŒåŒ…æœ‰èƒ½é‡ï¼Œä¼˜å…ˆç»™å¡”å……èƒ½
            if (tower && creep.store[RESOURCE_ENERGY] > 0) {
                if (creep.transfer(tower, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(tower, {visualizePathStyle: {stroke: '#ff0000'}});
                }
                return;
            }
            
            // å¦‚æžœæ²¡æœ‰å¡”æˆ–æ²¡æœ‰èƒ½é‡ï¼Œæ’¤é€€åˆ°æœ€è¿‘çš„å‡ºç”Ÿç‚¹
            const spawn = creep.pos.findClosestByPath(FIND_MY_SPAWNS);
            if (spawn && creep.pos.getRangeTo(spawn) > 3) {
                creep.moveTo(spawn, {visualizePathStyle: {stroke: '#ff0000'}});
                creep.say('ðŸš¨ æ’¤é€€!');
                return;
            }
        }
        
        // è‡ªåŠ¨æ¸…ç†æ— æ•ˆå†…å­˜
        if (!creep.memory.sourceId || !Game.getObjectById(creep.memory.sourceId)) {
            delete creep.memory.sourceId;
            delete creep.memory.cachedPath;
        }

        // âœ… å°è¯•é‡æ–°ç»‘å®š source
        if (!creep.memory.sourceId) {
            const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);
            if (source) {
                creep.memory.sourceId = source.id;
                const path = creep.pos.findPathTo(source, {
                    serialize: true,
                    ignoreCreeps: true
                });
                creep.memory.cachedPath = path;
            } else {
                // âœ… å¦‚æžœæ‰¾ä¸åˆ°èƒ½é‡æºï¼ŒmoveTo æŽ§åˆ¶å™¨é™„è¿‘ç­‰å¾…
                if (creep.room.controller) {
                    creep.moveTo(creep.room.controller);
                }
                return;
            }
        }

        const source = Game.getObjectById(creep.memory.sourceId);

        if (creep.store.getFreeCapacity() > 0) {
            // é¦–å…ˆå°è¯•ä»ŽContainerèŽ·å–èƒ½é‡
            const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {
                filter: s => s.structureType === STRUCTURE_CONTAINER &&
                    s.store[RESOURCE_ENERGY] > 0
            });

            if (container) {
                if (creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(container, {
                        visualizePathStyle: { stroke: '#ffaa00' },
                        reusePath: 3
                    });
                }
            } else if (source) {
                const harvestResult = creep.harvest(source);
                if (harvestResult === ERR_NOT_IN_RANGE) {
                    // ä½¿ç”¨å¸¦ç¼“å­˜çš„ç§»åŠ¨
                    if (creep.memory.cachedPath && creep.memory.cachedPath.length > 0) {
                        const moveResult = creep.moveByPath(creep.memory.cachedPath);
                        // âœ… fallbackï¼šå¦‚æžœ moveByPath è¿”å›ž ERR_NOT_FOUND æˆ– ERR_NO_PATHï¼Œåˆ™ç›´æŽ¥ moveTo
                        if (moveResult < 0) {
                            creep.moveTo(source, {
                                visualizePathStyle: { stroke: '#ffaa00' },
                                reusePath: 3
                            });
                            delete creep.memory.cachedPath;
                        } else if (creep.pos.isNearTo(source)) {
                            creep.memory.cachedPath = creep.pos.findPathTo(source, {
                                serialize: true,
                                ignoreCreeps: true
                            });
                        }
                    } else {
                        creep.moveTo(source, {
                            visualizePathStyle: { stroke: '#ffaa00' },
                            reusePath: 3
                        });
                    }
                }
            }
        } else {
            // èƒ½é‡è¿è¾“é€»è¾‘
            let target = creep.pos.findClosestByPath(FIND_STRUCTURES, {
                filter: s =>
                    (s.structureType === STRUCTURE_EXTENSION ||
                        s.structureType === STRUCTURE_SPAWN ||
                        s.structureType === STRUCTURE_TOWER) &&
                    s.store.getFreeCapacity(RESOURCE_ENERGY) > 0
            });

            if (!target) {
                target = creep.room.storage ||  // ä¼˜å…ˆä½¿ç”¨Storage
                    creep.pos.findClosestByPath(FIND_STRUCTURES, {
                        filter: s =>
                            s.structureType === STRUCTURE_CONTAINER &&
                            s.store.getFreeCapacity(RESOURCE_ENERGY) > 0
                    });
            }

            if (!target && creep.room.controller) {
                target = creep.room.controller;
            }

            if (target) {
                const result = (target.structureType === STRUCTURE_CONTROLLER)
                    ? creep.upgradeController(target)
                    : creep.transfer(target, RESOURCE_ENERGY);

                if (result === ERR_NOT_IN_RANGE) {
                    creep.moveTo(target, {
                        visualizePathStyle: { stroke: '#ffffff' },
                        reusePath: 3
                    });
                }

                if (!creep.pos.inRangeTo(target, 3)) {
                    delete creep.memory.cachedPath;
                }
            }
        }
    },
};